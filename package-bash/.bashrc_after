################################################################################

#                "Why not just put .bashrc in version control?"
# I use this "after" file because I find it more portable. The default
# $HOME/.bashrc changes a fair amount from machine to machine and I'd rather not
# make this file conform to that. Machine-specific stuff just goes in .bashrc.

# to link to this file from your local bashrc, add this:
# if [ -f  $HOME/.bashrc_after ]; then
#     source $HOME/.bashrc_after
# fi

# Based bashpillers can do "exec bash" to reload this file.
# (Cringe version is "source $HOME/.bashrc")

################################################################################

# TODO environment variables should be defined earlier, need to rethink ordering
# in this file
export PATH=$HOME/.local/bin:$PATH
export PATH=$HOME/.local/sam-bin:$PATH

# remember you can 'alias -p' to list active aliases
alias 'ls'='\ls --color=auto'
alias 'll'='ls -lh'
alias 'la'='ls -a'
alias 'lt'='ls -lt' # doesn't seem to work with exa
alias 'grep'='\grep --color=auto'
alias 'egrep'='\egrep --color=auto'
alias 'fgrep'='\fgrep --color=auto'
# note: you can use cp -P to not follow symlinks. can significantly shorten copies, if that's what you mean to do
alias 'cp'='cp --interactive'
alias 'rm'='rm --interactive'
alias 'mv'='mv --interactive'
alias 'mkdir'='mkdir --parents'
alias 'symlink'='ln -s'
alias 'g'='git'
alias 'gc'='git -C'
alias 'em'='emacs -nw'
alias 'ap'='apropos'
alias 'fzfp'='fzf --preview="less {}"'
alias 'hist'='history | sed "s/[0-9]\+//" | sed "s/^\s*//" | nvim'
alias 'sizema'='du -sh ./* | sort -h' # list sizes of things in current directory
alias 'peep'='nvim -R' # lol
alias 'less'='less --LONG-PROMPT --ignore-case'
alias 'vimless'='/usr/local/share/nvim/runtime/scripts/less.sh --clean' # I believe this is the right location, though it might be in macros/ instead of scripts/
alias 'vl'='vimless'
alias 'py'='python3'
alias 'python'='python3'
alias 'bt'='bluetoothctl'
alias 'xc'='xclip -selection clipboard -rmlastnl'
alias 'wat'='watch -ctn 0.2'
alias 'watls'='watch -ctn 0.2 ls --color=always'
alias 'gr'='grep -i'
alias 'pg'='pgrep -i'
alias 'rga'='rg --no-ignore --hidden -i' # 'ripgrep all', could also do 'rg -uu'
# alias 'tldr'='tldr --theme base16'
alias 's'='sessionizer'
alias 'ol'='ollama run llama3.1'
alias 'gccw'='gcc -Wall -Werror -Wextra -g -fsanitize=address,undefined,leak'
alias 'aout'='./a.out'
alias "gt"="go test ./... | sed 's/^ok/\o033[32mOK\o033[0m/; s/^FAIL/\o033[31mFAIL\o033[0m/'" # like "go test" but with colorized output
alias "dps"="docker ps -as"
alias 'mkx'='chmod ugo+x'
alias 'delete-the-fucking-zone-identifiers-windows-you-stupid-piece-of-garbage'='rm -i *:Zone.Identifier'
# Fix 'Exec format error' from windows programs (like explorer.exe) on WSL:
alias 'wsl-fix-bin'='sudo systemctl restart systemd-binfmt'

alias 'sudo-nvim'='sudo EDITOR=nvim visudo'

# alias 'ns'='nvim -S'
ns() {
    if [ $# -eq 0 ] && [ ! -f Session.vim ]; then
        echo "could not find Session.vim" >&2
        return 1
    fi
    nvim -S $@
}
complete -W '$(lsvim 2>/dev/null)' ns # search 'Programmable Completion' in bash(1)
alias "lsvim"="ls *.vim" # for easily listing vim sessions

# TODO move to separate script. this file should be bash-specific as much as possible.
# Merge compile commands for use with clangd.
merge-compile-commands() {
    # (use -mindepth as to not include the previous ./compile_commands.json)
    find -mindepth 2 -name "compile_commands.json" | xargs jq -s add >| compile_commands.json
    # Also see https://stackoverflow.com/questions/77394438/merge-multiple-compile-command-json-files
}

alias 'tarc'='tar czf'
alias 'tarx'='tar xzfk'
untarto() {
    mkdir --parents "$1"
    tar xzf "$2" -C "$1"
}

# cd to multiple places at once; easier up-a-dir
c() {
    if [ $# -eq 0 ]; then
        cd ".."
    elif [ $# -eq 1 ]; then
        cd "$1"
    else
        tmux split -c "$2"
        cd "$1"
    fi
}
alias 'cc'='cd ../..'
alias 'ccc'='cd ../../..'
alias 'cccc'='cd ../../../..'

if type "exa" &> /dev/null; then
    alias 'etree'='exa --tree'
fi
if type "batcat" &> /dev/null; then
    alias 'bat'='batcat'
fi

# don't overwrite files with the > redirect operator (use >| to forcefully redirect)
set -o noclobber

# quickly simulate WSL with `tmux new-window -e WSL_DISTRO_NAME=Ubuntu`
if [ ! -z "$WSL_DISTRO_NAME" ]; then
    # Historically on WSL, I used the wslu package to get `wslview`, which is
    # similar to xdg-open. But the version in apt is apparently broken or
    # something? Just use explorer.exe instead.
    alias 'x'='explorer.exe'
    # NOTE: when wsl exes break, use 'sudo systemctl restart systemd-binfmt'
    # TODO move all WSL things to the same place probably
else
    alias 'x'='xdg-open'
fi

# TODO come back to this and get some more binds that don't need <enter> please:
# not working right now
# recall: bind -x is like bind but keeps the current command typed out
# i should expand this quite a bit:
# within fzf, bind a certain key to open in a new tmux window, new tmux session,
# new tmux pane, cd into it, or just simply paste it on the current readline
# bind -x '"\C-xf":"find -maxdepth 2 -type d | fzf"'
# bind -x '"\C-xf":"READLINE_LINE=\$READLINE_LINE find -maxdepth 2 -type d | fzf"'
# (this escaping is nuts)

# (see bind section in SHELL BUILTIN COMMANDS in man bash)

# Remember that PARAMETER EXPANSION in bash(1) has all the string operations and
# whatnot

# experimental bash manual TOC
manbash () {
    if [ $# -ne 1 ]; then
        man bash
        return
    fi
    query=$(echo "$1" | tr A-Z a-z)
    if [ $query = "array" ] || [ $query = "arrays" ]; then
        REGEX='^\s*Arrays$'
    elif [ $query = "expansion" ]; then
        REGEX='^EXPANSION$'
    elif [ $query = "if" ]; then
        REGEX='^CONDITIONAL EXPRESSIONS$'
    elif [ $query = "builtin" ] || [ $query = "builtins" ]; then
        REGEX='^SHELL BUILTIN COMMANDS$'
    elif [ $query = "completion" ]; then
        REGEX='^\s*Programmable Completion$'
    fi
    man --pager="less -p '$REGEX'" bash
}

# TODO wouldn't it be good to have an offline copy of these docs i can live_grep through?
sc() {
    explorer.exe "https://www.shellcheck.net/wiki/SC$1"
}

# combine these and just detect whether the selection is a file or directory
cf() {
    target_directory=$(find . -type d -not -path "*/.git/*" 2>/dev/null | fzf)
    if [ ! -z "$target_directory" ]; then
        cd "$target_directory"
    fi
}
nf() {
    target_file=$(find . -not -path "*/.git/*" 2>/dev/null | fzf)
    if [ ! -z "$target_file" ]; then
        nvim "$target_file"
    fi
}

cl() {
    cd "$1" && ls
}

# shorter pushd, suppresses the "dirs"-like message that pushd normally outputs
pd() {
    if [ -z "$1" ]; then
        pushd "$HOME" 1>/dev/null
    else
        pushd "$1" 1>/dev/null
    fi
}

# make and then cd into directory
mcd() {
    if [ $# -eq 1 ]; then
        mkdir -p "$1"
        cd "$1"
    else
        echo "Expected name of directory to make. Ex: 'mcd myproject'"
    fi
}

# eventually, i might want to use w3m instead of the default browser
ddg() {
    # xdg-open "https://duckduckgo.com/lite/?q=$@"
    xdg-open "https://duckduckgo.com/?q=$@"
}
mdn() {
    # this doesn't work lol ðŸ’€
    xdg-open "https://developer.mozilla.org/en-US/search?q=$1"
}
ksearch() {
    xdg-open "https://www.kernel.org/doc/html/latest/search.html?q=$1"
}
nixpkg() {
    xdg-open "https://duckduckgo.com/?q=!nixpkg $@"
}
nixopt() {
    xdg-open "https://search.nixos.org/options?channel=25.11&query=$1"
}

markthis() {
    echo -e "\e[34m@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\e[0m"
    echo -e "\e[32m@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\e[0m"
}

# open tmux on startup!!! we love tmux!!!
if [ "$REMOTE" ]; then
    : # (noop)
elif [ -z "$TMUX" ]; then
    tmux attach || tmux new-session -s "tmuxma"
else
    # let's try having the tmux status on for a bit
    : # tmux set status off
fi

# check the "shopt" command section in bash(1) for more fun stuff
# typing a directory name will cd you into it
shopt -s autocd
# correct minor mistakes with cd. this doesn't appear to stack with autocd :(
shopt -s cdspell

# for this section, check out the PROMPTING heading in bash(1)
# different prompt so i remember when i'm on a remote machine
if [ "$REMOTE" ]; then
    # export PS1="\[\e[0;35m\]\w\[\e[0;37m\]$ \[\e[0m\]"
    # alternative prefix so local tmux doesn't conflict with remote tmux
    tmux set -g prefix C-space
else
    export PROMPT_DIRTRIM=4
    export PS1="\n\[\e[0;36m\]\w\[\e[0;37m\]$ \[\e[0m\]"
    export PS2="> "
fi

# TODO add number of background jobs to ps1, in case i forget i backgrounded
# something

# should probably just add timestamp to PS1. Can put it on the far right so it's
# out of the way. Maybe there's a good use of `bind -x` with this to run
# commands or something idk

if [ -z "$TMUX" ]; then
    PS1="(no tmux) $PS1"
fi
# add OSC 133, indicating the end of a prompt (broken rn)
# Note that nvim has a guide in :h terminal-osc133 for setting this up
# export PROMPT_COMMAND="printf \\"\033]133;A\007\\"; $PROMPT_COMMAND"

# TODO need bash completion of mn to match man, also reconcile manfzf with man and mn. what uses nvim and what uses default?
alias 'mn'='man --all --pager="nvim +Man!"'
mansearch() {
    if [ $# -eq 0 ]; then
        echo 'Example: mansearch bash expansion'
        return
    fi
    man --pager="less -p $2" "$1"
}
alias mansections='man man | sed -n "22,30p"'

# fzf catppuccin theme (https://github.com/catppuccin/fzf)
export FZF_DEFAULT_OPTS=" \
--color=bg+:#363a4f,bg:#24273a,spinner:#f4dbd6,hl:#ed8796 \
--color=fg:#cad3f5,header:#ed8796,info:#c6a0f6,pointer:#f4dbd6 \
--color=marker:#f4dbd6,fg+:#cad3f5,prompt:#c6a0f6,hl+:#ed8796"

# infinite history (based on https://stackoverflow.com/a/19533853/19130514)
export HISTSIZE=
export HISTFILESIZE=
# WARN: you must comment out the definitions of HISTSIZE and HISTFILESIZE in
# your bashrc! otherwise some shells might clear history (for some reason).
# because of this, it's good to change the history file, just to be safe:
export HISTFILE=~/.bash_history_infinite
export HISTTIMEFORMAT='(%F %T)  '

# share tmux history throughout all tmux panes/windows/sessions. see these posts:
# https://stackoverflow.com/questions/12247777/share-history-between-panes-windows
# https://web.archive.org/web/20170104092506/http://briancarper.net/blog/248.html
# WARN: this is very dangerous if you mindlessly up arrow or ctrl-p to run the
# previous command. the previous command will change underneath you because of
# activity in other shells.
shopt -s histappend
export PROMPT_COMMAND="history -a; history -n; $PROMPT_COMMAND" # (you can search for "history -a" in bash(1) and it'll work)

# fun bash facts: with the default value of HISTCONTROL (ignoreboth), you can
# run a command with a space at the front to prevent it from appearing in
# history. this is handy for dangerous commands that you don't want to
# accidentally reuse. here is is though in case it's not the default
export HISTCONTROL=ignoreboth

# this is supposed to fix the terminal freezing and showing a ';' character,
# then needed like seventeen ctrl+c inputs to unfreeze it. especially on WSL.
# https://github.com/microsoft/WSL/issues/7292
shopt -s no_empty_cmd_completion
# (if you don't experience the aforementioned problem, you might be tempted to
# delete this line. at least leave it commented out in case you need it again)

export VISUAL=nvim
export EDITOR=nvim
# i don't like vi mode but it's here if you want
# set -o vi

bind '"\C-xq": "\"\"\C-b"' # this usually works
bind '"\C-x\C-q": "\C-q"' # this might not work on some terminals
bind '"\C-xt": "~"'
bind '"\C-x\C-t": "\C-xt"'
bind '"\C-xb": "``\C-b"'
bind '"\C-x\C-b": "\C-xb"'
bind '"\C-xh": " --help"'
bind '"\C-x\C-h": "\C-xh"'
bind '"\C-xv": " --version"'
bind '"\C-x\C-v": "\C-xv"'
bind '"\C-xf": "\"$(fzf)\""'
bind '"\C-x\C-f": "\C-xf"'
bind '"\C-xd": " 2>/dev/null"'
bind '"\C-x\C-d": "\C-xd"'
bind '"\C-xi": "192.168."'
bind '"\C-x\C-i": "\C-xi"'
bind '"\C-x?": "man bash | less -p \"Commands for Moving\"\n"' # (open keybind reference)
# ctrl-alt-p to search history *including current command*. Like ctrl-r but you
# can decide to search history after you've already typed something.
bind '"\e\C-p":history-search-backward'
bind '"\e\C-n":history-search-forward'

# WSL might not define the XDG family of environment variables for you
if [ -z "$XDG_CONFIG_HOME" ]; then
    export XDG_CONFIG_HOME=$HOME/.config/
fi

export TRASH=~/.local/share/Trash/files
trash() {
    mkdir -p "$TRASH"
    if [ "$1" = "-i" ] || [ "$1" = "--interactive" ]; then
        shift
        for file_to_trash in "$@"; do
            read -p "trash: move '$file_to_trash' to trash? " response
            if [ "$response" = "y" ] || [ "$response" = "Y" ]; then
                mv --force --backup=numbered -t "$TRASH" "$file_to_trash"
            fi
        done
    else
        mv --force --backup=numbered -t "$TRASH" "$@"
    fi
}

# the classic "find | fzf" wombo combo
SAM_F_MAX_DEPTH=5
f () {
    # TODO double check this works. i am currently seeing 'f' open global
    # search. oh duh its because some dirs are included even in lowercase f
    if [ $# -eq 0 ]; then
        f_starting_dir="."
    else
        f_starting_dir="$1"
    fi
    selected=$({
        find "$f_starting_dir" \
            -maxdepth "$SAM_F_MAX_DEPTH" \
            -not -path "*/.git/*" \
            -not -path "*/.stversions*" \
            -not -name ".stfolder" \
            2>/dev/null
        # TODO this needs to be fixed so that f and F are properly differentiated, also depth and going across filesystems is weird
        find "/mnt/sn570/kablam/" \
            -maxdepth "$SAM_F_MAX_DEPTH" \
            -not -path "*/.git/*" \
            -not -path "*/.stversions*" \
            -not -name ".stfolder" \
            2>/dev/null
        # more 'find' commands can go here
    } | fzf --preview='less {}' --preview-window=right,50%)
    if [ -z "$selected" ]; then
        return 1
    fi
    # use --dereference as to not mistreat symlinks as files
    if [ "$(file --brief --dereference "$selected")" = "directory" ]; then
        cd "$selected"
    else
        # eventually, it would be good to xdg-open any images, videos, and so on
        nvim "$selected"
    fi
}
alias F='f ~'
alias C='f ..'
alias CC='f ../..'
alias CCC='f ../../..'
alias CCCC='f ../../../..'

dotfiles_path="$(get-dotfiles-path)"
dotfiles() {
    if [ $# -eq 0 ]; then
        cd "$dotfiles_path"
    else
        cd "$dotfiles_path/$1"
    fi
}
complete -W '$(ls $dotfiles_path)' dotfiles

worktree-cd () {
    if [ $# -ne 1 ]; then
        echo "Expected name of worktree to cd into." >&2
        return 1
    fi
    path=$(git worktree list | grep "$1" | awk '{print $1}')
    if [ -z "$path" ]; then
        echo "Worktree '$1' not found. Available worktrees: $(git worktree list)" >&2
        return 1
    fi
    cd "$path"
}
alias 'wcd'='worktree-cd'
# TODO bash completion for worktree-cd

worktree-fzf() {
    path=$(git worktree list | fzf | awk '{print $1}')
    if [ -z "$path" ]; then
        return 0
    fi
    cd "$path"
}
alias 'wfzf'='worktree-fzf'

tts() {
    if [ $# -eq 0 ]; then
        echo "Expected text to tts-ify" >&2
        return 1
    fi
    ttsfile='/tmp/ttsfile.wav'
    pico2wave --wave="$ttsfile" "$@" # (pico2wave is in debian package libttspico-utils)
    aplay "$ttsfile"
    rm --force "$ttsfile"
}

# todo: make a function analogous to the builtin 'help' that explains some of my
# more common aliases/functions/scripts. add color tho. color pretty

# note: nodejs on *some* package managers (apt, i'm looking at you) may be
# really out of date. this breaks some LSPs. use this to get newer nodejs:
# curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash
# nvm install 20



# NOTE make sure you have ffmpeg installed to use yt-dlp.

# A download archive file can be backed up to all my devices via cron. This is
# pretty useful to have (in case I lose the actual videos) while not taking up
# countless gigabytes of video across several devices. However, I don't use an
# archive file because it requires manually deleting videos from both the
# archive and from the filesystem. Besides, 'ls > archive.txt' on a cronjob is
# basically the same thing if not more useful.
export YTDLP_DOWNLOAD_DIR="/home/sam/kablam/public/ytdlp"
alias "yt-dlp-video"="yt-dlp --embed-metadata --embed-subs --embed-thumbnail --sponsorblock-mark all -o $YTDLP_DOWNLOAD_DIR/'[%(id)s] %(title)s.%(ext)s'"
alias 'yt-dlp-audio'='yt-dlp --embed-metadata --extract-audio'

exif-delete() { # Delete exif data from an image
    if ! type "exiftool" &> /dev/null; then
        echo exiftool not installed
        return 1
    fi
    read -p "Are you sure you want to delete ALL exif data? (y/n) " response
    if [ "$response" = 'y' ]; then
        exiftool -all='' "$@"
    else
        echo "Not deleting exif data"
    fi
}

# TODO make the tmux versions just call these, these can be used both in tmux
# and manually, so they're more general
alias "B"="$EDITOR ~/.bashrc_after"
alias "G"="$EDITOR $XDG_CONFIG_HOME/git/config"
alias "T"="$EDITOR $XDG_CONFIG_HOME/tmux/tmux.conf"
alias "I"="cd $(get-dotfiles-path)"
alias "H"="$EDITOR ~/.ssh/config"
alias "N"="nvim +'norm G' ~/notes.md"

# vim: filetype=sh
