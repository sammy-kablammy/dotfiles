# vim: syntax=gitconfig

# example for sourcing another file
# [include]
#   path = /path/to/other/gitconfig

[user]
    email = 98327570+sammy-kablammy@users.noreply.github.com
    name = sammy-kablammy
[core]
    editor = nvim
    # git likes to dump a bunch of garbage to stdout when exiting the pager for
    # commands like 'git log' and 'git show', i don't like this
	pager = less --LONG-PROMPT --ignore-case -+X # (the + re-enables the option)
    excludesFile = "~/.config/git/ignore"
[init]
    defaultBranch = main
[push]
    default = simple
    autoSetupRemote = true # (allows 'git push' on new, upstreamless branches)
[pull]
    rebase = false
[diff]
    tool = nvimdiff
[difftool]
    prompt = false
[merge]
    tool = nvimdiff
[commit]
    verbose = true
[url "ssh://git@github.com/"]
    insteadOf = gh:
[url "ssh://git@github.com/"]
    # Push over SSH since I prefer SSH keys to github's auth. Git also supports
    # 'pushInsteadOf' if you just want this to apply to pushing.
	; insteadOf = https://github.com/
    # Actually you can't do this because it fails when you aren't authorized?
    # even for public repos? idk
[advice]
    # detachedHead = false
[help]
    # Show but do not apply autocorrect suggestions
    autoCorrect = 0
[fetch]
    recurseSubmodules = no
[alias]
    alias = "!f() { git config --list | grep 'alias'; }; f"
    b = "branch -vv"
    ca = "commit --amend"
    co = "checkout"
    conflicts = "!f() { git ls-files | xargs grep -il '<<<<<<<' | $EDITOR; }; f"
    currentbranch = "rev-parse --abbrev-ref HEAD"
    ds = "diff --stat"
    dt = "difftool --prompt"
    dty = "difftool --prompt -y --trust-exit-code" # (use vim's :cq to end diffing)
    dts = "difftool --prompt --staged"
    f = "fetch"
    fq = "fetch --quiet"
    fs = "!f() { git fetch && git status --short --branch; }; f"
    fst = "!f() { git fetch && git status; }; f"
    h = "rev-parse HEAD"
    hc = "!f() { git rev-parse HEAD | xclip -selection clipboard -rmlastnl; }; f"
    l = "log --all --graph --decorate --oneline -7"
    la = "log --all --graph --decorate --oneline -9999"
    lb = "log --graph --decorate --oneline HEAD~7..HEAD" # "log branch"
    lga = "log --all --graph --decorate -9999"
    laoganma = "!f() { echo '+100 social credit'; }; f"
    ls = "ls-files"
    # list-ignored = "ls-files --exclude-standard" # this is backwards, the flag is confusingly named though i admit
    modified = "!f() { git ls-files --modified | xargs $EDITOR; }; f"
    mt = "mergetool"
    pullr = "pull --rebase=interactive"
    pulls = "pull --autostash"
    remotes = "remote -v"
    rc = "rebase --continue"
    ref = "reflog --date=short"
    rl = "reflog"
    s = "status --short --branch"
    sh = "show -5 --pretty=oneline"
    sl = "stash list"
    sp = "stash pop"
    sst = "submodule status"
    st = "status"
    suf = "submodule update --force" # reset submodule to pinned commit
    sup = "submodule update --remote" # checkout submodule to what's in .gitmodules
    sw = "switch"
    type = "!f() { git config --list | grep ^alias.$1; }; f" # like the "type" shell builtin but for git
    unstage = "restore --staged"
    untrack = "rm --cached" # remove file from repo without deleting from filesystem
    w = "worktree list"

    # Pickaxe should generally be used for searching across history. List
    # commits that added, removed, or changed a given string.
    pick = "!f() git log -S \"$@\" --pickaxe-regex; f"
    pickinsensitive = "!f() git log -i -S \"$@\"; f"
    # This literally greps across the entire history (grepping files, not commit
    # messages or diffs i think). It takes forever but can be useful in dire
    # situations where you just really, really need to find something and don't
    # want to think too much.
    grepall = "!f() { git grep -i \"$@\" $(git rev-list --all); }; f"
